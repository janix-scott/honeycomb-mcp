import { z } from "zod";
import { HoneycombAPI } from "../api/client.js";
import { handleToolError } from "../utils/tool-error.js";
import { QueryToolSchema } from "../types/schema.js";
import { summarizeResults } from "../utils/transformations.js";

/**
 * Validates query parameters against Honeycomb API constraints
 * @param params - The query parameters to validate
 * @throws Error if validation fails with a descriptive message
 */
function validateQueryParameters(params: z.infer<typeof QueryToolSchema>): void {
  // Validate required parameters
  if (!params.environment) {
    throw new Error("Missing required parameter: environment");
  }
  if (!params.dataset) {
    throw new Error("Missing required parameter: dataset");
  }
  if (!params.calculations || params.calculations.length === 0) {
    throw new Error("At least one calculation is required");
  }
  
  // Get all calculation identifiers for validation
  const calculationIds = params.calculations.map(calc => {
    if (calc.op === "COUNT" || calc.op === "CONCURRENCY") {
      return calc.op;
    }
    return `${calc.op}(${calc.column})`;
  });
  
  // Validate orders if they reference calculations or breakdowns
  if (params.orders) {
    const calculationOps = params.calculations.map(calc => calc.op);
    const validOrderOps = [...calculationOps];
    
    // Add COUNT and CONCURRENCY if not already in calculationOps
    if (!validOrderOps.includes("COUNT")) validOrderOps.push("COUNT");
    if (!validOrderOps.includes("CONCURRENCY")) validOrderOps.push("CONCURRENCY");
    
    // Check if orders reference valid operations
    for (const order of params.orders) {
      // Per docs: "The ORDER BY clauses available to you for a particular query are influenced by 
      // whether any GROUP BY or VISUALIZE clauses are also specified. If none are, you may order 
      // by any of the attributes contained in the dataset. However, once a GROUP BY or VISUALIZE 
      // clause exists, you may only order by the values generated by those clauses."
      if (order.column && !params.breakdowns?.includes(order.column) && 
          !params.calculations.some(calc => calc.column === order.column)) {
        throw new Error(`Order column '${order.column}' must be in breakdowns or calculations. According to Honeycomb docs, once a GROUP BY (breakdowns) or VISUALIZE (calculations) clause exists, you may only order by the values generated by those clauses.`);
      }
      
      if (order.op === "HEATMAP") {
        throw new Error("HEATMAP cannot be used in orders as specified in Honeycomb's documentation.");
      }
      
      if (!order.column && !["COUNT", "CONCURRENCY"].includes(order.op)) {
        throw new Error(`Operation '${order.op}' requires a column unless it is COUNT or CONCURRENCY.`);
      }
    }
  }
  
  // Validate having clauses
  if (params.having) {
    for (const having of params.having) {
      // Per docs: "The HAVING clause always refers to one of the VISUALIZE clauses."
      // Ensure the calculate_op + column combination exists in calculations
      const havingOpId = having.column 
        ? `${having.calculate_op}(${having.column})` 
        : having.calculate_op;
        
      const matchingCalculation = params.calculations.some(calc => {
        if ((calc.op === "COUNT" || calc.op === "CONCURRENCY") && 
            having.calculate_op === calc.op) {
          return true;
        }
        
        return calc.op === having.calculate_op && calc.column === having.column;
      });
      
      if (!matchingCalculation) {
        throw new Error(`HAVING clause with calculate_op '${having.calculate_op}' ${having.column ? `and column '${having.column}'` : ''} must refer to one of the VISUALIZE (calculations) clauses. Available calculations: ${calculationIds.join(', ')}`);
      }
    }
  }
  
  // Handle time parameters based on Honeycomb API specifications
  
  // 1. Validate time-related parameters
  if (params.start_time && params.end_time && params.time_range) {
    // Cannot have all three
    throw new Error("Cannot specify time_range, start_time, and end_time simultaneously. Use time_range with either start_time or end_time, or use start_time and end_time without time_range.");
  }
  
  // 2. Validate granularity parameter
  if (params.granularity !== undefined) {
    // When using granularity, we need a time window (either time_range or start_time+end_time)
    if (!params.time_range && !(params.start_time && params.end_time)) {
      throw new Error("When using granularity, you must specify either time_range or both start_time and end_time to define the time window.");
    }
    
    // Granularity must be a positive integer
    if (params.granularity <= 0 || !Number.isInteger(params.granularity)) {
      throw new Error("Granularity value must be a positive integer representing seconds.");
    }
    
    // Validate granularity isn't too small for the time window
    if (params.time_range && params.granularity < Math.max(1, Math.floor(params.time_range / 300))) {
      // For larger time ranges, granularity shouldn't create too many data points (max ~300 points is reasonable)
      throw new Error(`Granularity value (${params.granularity}s) is too small for the requested time range (${params.time_range}s). This would create too many data points for the API to process efficiently.`);
    }
    
    // For start_time/end_time combination
    if (params.start_time && params.end_time) {
      const timeWindowSeconds = Math.abs(params.end_time - params.start_time);
      if (params.granularity < Math.max(1, Math.floor(timeWindowSeconds / 300))) {
        throw new Error(`Granularity value (${params.granularity}s) is too small for the requested time window (${timeWindowSeconds}s). This would create too many data points for the API to process efficiently.`);
      }
    }
  }
}

/**
 * Helper function to execute a query and process the results
 */
async function executeQuery(
  api: HoneycombAPI, 
  params: z.infer<typeof QueryToolSchema>,
  hasHeatmap: boolean
) {
  // Execute the query
  const result = await api.runAnalysisQuery(params.environment, params.dataset, params);
  
  try {
    // Simplify the response to reduce context window usage
    const simplifiedResponse = {
      results: result.data?.results || [],
      // Only include series data if heatmap calculation is present (it's usually large)
      ...(hasHeatmap ? { series: result.data?.series || [] } : {}),
      
      // Include a query URL if available 
      query_url: result.links?.query_url || null,
      
      // Add summary statistics for numeric columns
      summary: summarizeResults(result.data?.results || [], params),
      
      // Add query metadata for context
      metadata: {
        environment: params.environment,
        dataset: params.dataset,
        executedAt: new Date().toISOString(),
        resultCount: result.data?.results?.length || 0
      }
    };
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(simplifiedResponse, null, 2),
        },
      ],
    };
  } catch (processingError) {
    // Handle result processing errors separately to still return partial results
    console.error("Error processing query results:", processingError);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            results: result.data?.results || [],
            query_url: result.links?.query_url || null,
            error: `Error processing results: ${processingError instanceof Error ? processingError.message : String(processingError)}`
          }, null, 2),
        },
      ],
    };
  }
}

/**
 * Creates a tool for running queries against a Honeycomb dataset
 * 
 * This tool handles construction, validation, execution, and summarization of
 * Honeycomb queries, returning both raw results and useful statistical summaries.
 * 
 * @param api - The Honeycomb API client
 * @returns A configured tool object with name, schema, and handler
 */
export function createRunQueryTool(api: HoneycombAPI) {
  return {
    name: "run_query",
    description: "Executes a Honeycomb query against a dataset, performing validation and returning raw results along with statistical summaries. This tool handles construction, validation, execution, and summarization of Honeycomb queries.",
    schema: QueryToolSchema.shape,
    /**
     * Handles the run_query tool request
     * 
     * @param params - The parameters for the query
     * @returns A formatted response with query results and summary statistics
     */
    handler: async (params: z.infer<typeof QueryToolSchema>) => {
      try {
        // Validate query parameters before execution
        validateQueryParameters(params);
        
        // Check for heatmap calculations to determine if series data should be included
        const hasHeatmap = params.calculations.some(calc => calc.op === "HEATMAP");

        // Execute the query with retry logic for transient API issues
        const maxRetries = 3;
        let lastError: unknown = null;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            return await executeQuery(api, params, hasHeatmap);
          } catch (error) {
            lastError = error;
            console.error(`Query attempt ${attempt} failed: ${error instanceof Error ? error.message : String(error)}`);
            
            // Only retry if not the last attempt
            if (attempt < maxRetries) {
              console.error(`Retrying in ${attempt * 500}ms...`);
              await new Promise(resolve => setTimeout(resolve, attempt * 500));
            }
          }
        }
        
        // If we get here, all attempts failed
        throw lastError || new Error("All query attempts failed");
      } catch (error) {
        return handleToolError(error, "run_query");
      }
    }
  };
}